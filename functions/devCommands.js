// Comandos de desenvolvedor
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import Groq from 'groq-sdk';
import { sendSafeMessage } from './messageHandler.js';
import { getNumberFromJid } from './utils.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const GLOBAL_DEV_MODE = String(process.env.IMAVY_DEV_MODE || 'false').toLowerCase() === 'true';

const groq = new Groq({
    apiKey: process.env.GROQ_API_KEY || 'your-groq-api-key-here'
});

// IDs dos desenvolvedores autorizados
const DEV_IDS = (process.env.DEV_IDS || '').split(',').filter(Boolean);
function loadAdminIds() {
    const fromEnv = (process.env.AUTHORIZED_IDS || '')
        .split(',')
        .map((id) => id.trim())
        .filter(Boolean);

    const adminsPath = path.join(__dirname, '..', 'admins.json');
    let fromFile = [];

    try {
        if (fs.existsSync(adminsPath)) {
            const parsed = JSON.parse(fs.readFileSync(adminsPath, 'utf8'));
            fromFile = Array.isArray(parsed?.admins) ? parsed.admins : [];
        }
    } catch (error) {
        console.warn('Falha ao ler admins.json para permissao DEV:', error.message || String(error));
    }

    return [...fromEnv, ...fromFile];
}

// Modo desenvolvedor ativo por usuÃ¡rio
const devModeActive = new Map();
const devModeForcedOff = new Set();
const conversationHistory = new Map();
const commandCreationState = new Map();
const pendingCommandApproval = new Map();
const DEV_GENERATED_MARKER = '// AUTO-GENERATED BY DEV MODE';
const DEV_AUTO_RESTART_AFTER_CREATE = String(process.env.DEV_AUTO_RESTART_AFTER_CREATE || 'true').toLowerCase() === 'true';

export function isDev(userId) {
    const cleanId = userId.replace('@s.whatsapp.net', '').replace('@lid', '');
    const userNumber = getNumberFromJid(userId);
    const adminIds = loadAdminIds();
    console.log('DEBUG DEV - userId:', userId);
    console.log('DEBUG DEV - cleanId:', cleanId);
    console.log('DEBUG DEV - DEV_IDS:', DEV_IDS);
    const isExplicitDev = DEV_IDS.some((devId) => {
        const trimmed = devId.trim();
        if (!trimmed) return false;
        if (cleanId.includes(trimmed)) return true;
        return userNumber && userNumber === getNumberFromJid(trimmed);
    });
    const isAdmin = adminIds.some((adminId) => {
        if (userId === adminId) return true;
        const adminNumber = getNumberFromJid(adminId);
        return Boolean(userNumber) && Boolean(adminNumber) && userNumber === adminNumber;
    });
    const isAuthorized = isExplicitDev || isAdmin;
    console.log('DEBUG DEV - isAuthorized:', isAuthorized);
    return isAuthorized;
}

export function isDevModeActive(userId) {
    if (GLOBAL_DEV_MODE && isDev(userId) && !devModeForcedOff.has(userId)) {
        return true;
    }
    return devModeActive.get(userId) === true;
}

export function activateDevMode(userId) {
    devModeForcedOff.delete(userId);
    devModeActive.set(userId, true);
    conversationHistory.set(userId, []);
}

export function deactivateDevMode(userId) {
    if (GLOBAL_DEV_MODE) {
        devModeForcedOff.add(userId);
    }
    devModeActive.delete(userId);
    conversationHistory.delete(userId);
    commandCreationState.delete(userId);
    pendingCommandApproval.delete(userId);
}

function getHistory(userId) {
    if (!conversationHistory.has(userId)) {
        conversationHistory.set(userId, []);
    }
    return conversationHistory.get(userId);
}

function addToHistory(userId, role, content) {
    const history = getHistory(userId);
    history.push({ role, content });
    if (history.length > 20) history.shift();
}

export async function handleDevCommand(sock, message, text) {
    const senderId = message.key.participant || message.key.remoteJid;
    const chatId = message.key.remoteJid;
    const isPrivate = !chatId.endsWith('@g.us');

    if (!isDev(senderId)) {
        await sendSafeMessage(sock, chatId, { text: 'âŒ Acesso negado. Comando apenas para desenvolvedores.' });
        return;
    }

    // Ativar modo dev no privado
    if (text.trim() === '/dev' && isPrivate) {
        activateDevMode(senderId);
        const welcomeMsg = `ðŸ¤– *MODO DESENVOLVEDOR ATIVADO* ðŸ¤–

ðŸ‘‹ OlÃ¡, mestre! Sou seu assistente de desenvolvimento.

ðŸ’¡ Agora vocÃª pode conversar comigo naturalmente:

â€¢ "Crie um comando de sorteio"
â€¢ "Adicione funÃ§Ã£o de enquete"
â€¢ "Quero um comando que..."
â€¢ "Como faÃ§o para..."

ðŸ› ï¸ Comandos rÃ¡pidos:
â€¢ /dev off - Desativar modo
â€¢ /dev status - Status do sistema
â€¢ /dev logs - Ver logs
â€¢ /dev restart - Reiniciar bot

âœ¨ Estou pronto para criar qualquer funÃ§Ã£o que vocÃª imaginar!`;
        await sendSafeMessage(sock, chatId, { text: welcomeMsg });
        return;
    }

    const args = text.split(' ');
    const subCmd = args[1]?.toLowerCase();

    if (subCmd === 'eval') {
        // Executar cÃ³digo JavaScript
        const code = args.slice(2).join(' ');
        try {
            const result = eval(code);
            await sendSafeMessage(sock, chatId, { text: `âœ… Resultado:\n${JSON.stringify(result, null, 2)}` });
        } catch (e) {
            await sendSafeMessage(sock, chatId, { text: `âŒ Erro:\n${e.message}` });
        }
    } else if (subCmd === 'restart') {
        await sendSafeMessage(sock, chatId, { text: 'ðŸ”„ Reiniciando bot...' });
        process.exit(0);
    } else if (subCmd === 'logs') {
        const requestedLines = Number.parseInt(args[2], 10);
        const result = readRecentLogs(Number.isFinite(requestedLines) ? requestedLines : 20, 3000);
        if (!result.ok) {
            await sendSafeMessage(sock, chatId, { text: `Erro ao ler logs: ${result.message}` });
            return;
        }
        await sendSafeMessage(sock, chatId, { text: `ULTIMOS LOGS (${result.safeLines} linhas)\n\n${result.text}` });
    } else if (subCmd === 'status') {
        const uptime = process.uptime();
        const memory = process.memoryUsage();
        const status = `STATUS DO BOT\n\nUptime: ${Math.floor(uptime / 60)}min\nMemoria: ${Math.floor(memory.heapUsed / 1024 / 1024)}MB\nPID: ${process.pid}\nDev global: ${GLOBAL_DEV_MODE ? 'ATIVO' : 'DESATIVADO'}\nDev atual: ${isDevModeActive(senderId) ? 'ATIVO' : 'DESATIVADO'}`;
        await sendSafeMessage(sock, chatId, { text: status });
    } else if (subCmd === 'backup') {
        await sendSafeMessage(sock, chatId, { text: 'Criando backup...' });
        await sendSafeMessage(sock, chatId, { text: 'Backup criado!' });
    } else if (subCmd === 'on') {
        activateDevMode(senderId);
        await sendSafeMessage(sock, chatId, { text: 'Modo desenvolvedor ativado para este chat.' });
    } else if (subCmd === 'off') {
        deactivateDevMode(senderId);
        const offMsg = GLOBAL_DEV_MODE
            ? 'Modo desenvolvedor desativado para voce neste chat (override local aplicado).'
            : 'Modo desenvolvedor desativado.';
        await sendSafeMessage(sock, chatId, { text: offMsg });
    } else {
        const help = `COMANDOS DEV\n\n/dev - Ativar modo IA (privado)\n/dev on - Ativar modo neste chat\n/dev off - Desativar modo neste chat\n/dev eval [codigo] - Executa JS\n/dev restart - Reinicia bot\n/dev logs - Ultimos logs\n/dev status - Status do sistema\n/dev backup - Backup manual`;
        await sendSafeMessage(sock, chatId, { text: help });
    }
}

function isApprovalText(text) {
    return /^(aprovar|aprovado|aprovo|sim|ok|confirmo)$/i.test(String(text || '').trim());
}

function isCancelText(text) {
    return /^(cancelar|cancela|nao|n?o|parar|stop)$/i.test(String(text || '').trim());
}

function looksLikeCommandCreationRequest(text) {
    const t = String(text || '').toLowerCase();
    return t.includes('criar comando')
        || t.includes('crie um comando')
        || t.includes('novo comando')
        || t.includes('comando que');
}

async function persistGeneratedCommand(result) {
    const fileName = `${result.commandName}.js`;
    const customDir = path.join(__dirname, 'custom');
    if (!fs.existsSync(customDir)) {
        fs.mkdirSync(customDir, { recursive: true });
    }

    const filePath = path.join(customDir, fileName);
    if (fs.existsSync(filePath)) {
        const existing = fs.readFileSync(filePath, 'utf8');
        if (!existing.includes(DEV_GENERATED_MARKER)) {
            throw new Error(`Arquivo ${fileName} ja existe e e manual. Escolha outro nome para nao sobrescrever.`);
        }
    }

    const code = String(result.code || '').trim();
    fs.writeFileSync(filePath, `${DEV_GENERATED_MARKER}\n${code}\n`);
    ensureCommandHandlerExport(filePath, result.commandName);
    await integrateCommand(result.commandName, result.commandTrigger, result.isPublic);

    return {
        fileName,
        trigger: result.commandTrigger,
        isPublic: Boolean(result.isPublic),
        usage: result.usage || 'Sem exemplo',
        logic: result.logic || 'Sem descricao'
    };
}

function validateGeneratedCommandResult(result) {
    const commandName = String(result?.commandName || '');
    const trigger = String(result?.commandTrigger || '');
    const code = String(result?.code || '');

    if (!/^[A-Za-z][A-Za-z0-9_]*$/.test(commandName)) {
        throw new Error('commandName invalido. Use apenas letras, numeros e underscore.');
    }
    if (!/^[/!][A-Za-z0-9_-]+$/.test(trigger)) {
        throw new Error('commandTrigger invalido. Use formato /comando ou !comando.');
    }
    if (!/export\s+/m.test(code)) {
        throw new Error('Codigo invalido: faltou export de handler.');
    }
    if (/client\.on\s*\(/i.test(code) || /new\s+Client\s*\(/i.test(code)) {
        throw new Error('Codigo invalido para este bot: nao use listeners/clientes novos dentro de comando custom.');
    }
}

export async function handleDevConversation(sock, senderId, messageText) {
    const chatId = senderId;
    const rawInput = String(messageText || '').trim();
    if (!rawInput) return;

    const pending = pendingCommandApproval.get(senderId);
    if (pending) {
        if (isApprovalText(rawInput)) {
            pendingCommandApproval.delete(senderId);
            try {
                const saved = await persistGeneratedCommand(pending);
                await sendSafeMessage(sock, chatId, {
                    text: `COMANDO APROVADO E CRIADO\nArquivo: functions/custom/${saved.fileName}\nGatilho: ${saved.trigger}\nPublico: ${saved.isPublic ? 'Sim' : 'Nao'}\nUso: ${saved.usage}\n\nLogica:\n${saved.logic}`
                });

                if (DEV_AUTO_RESTART_AFTER_CREATE) {
                    await sendSafeMessage(sock, chatId, { text: 'Reiniciando o bot para ativar o novo comando...' });
                    setTimeout(() => process.exit(0), 1200);
                } else {
                    await sendSafeMessage(sock, chatId, { text: 'Comando salvo. Reinicie o bot para carregar o novo comando.' });
                }
            } catch (error) {
                await sendSafeMessage(sock, chatId, { text: `Falha ao criar comando: ${error.message || String(error)}` });
            }
            return;
        }

        if (isCancelText(rawInput)) {
            pendingCommandApproval.delete(senderId);
            await sendSafeMessage(sock, chatId, { text: 'Criacao cancelada. Nenhum arquivo foi alterado.' });
            return;
        }

        await sendSafeMessage(sock, chatId, { text: 'Responda APROVAR para criar ou CANCELAR para abortar.' });
        return;
    }

    const creationState = commandCreationState.get(senderId);
    if (creationState?.step === 'intent') {
        creationState.intent = rawInput;
        creationState.step = 'response';
        commandCreationState.set(senderId, creationState);
        await sendSafeMessage(sock, chatId, { text: '2/3 O que o comando deve responder/mostrar quando for enviado?' });
        return;
    }

    let effectivePrompt = rawInput;
    if (creationState?.step === 'response') {
        creationState.responseSpec = rawInput;
        commandCreationState.delete(senderId);
        effectivePrompt = `Crie um comando WhatsApp para o bot.\nIntencao: ${creationState.intent}\nResposta esperada: ${creationState.responseSpec}\nGere JSON no formato combinado (type=code com commandName, commandTrigger, code, usage, isPublic, logic, response).`;
    } else if (looksLikeCommandCreationRequest(rawInput)) {
        commandCreationState.set(senderId, { step: 'intent' });
        await sendSafeMessage(sock, chatId, { text: '1/3 Qual a intencao principal do comando que voce quer criar?' });
        return;
    }

    await sendSafeMessage(sock, chatId, { text: 'Analisando sua solicitacao...' });

    try {
        const history = getHistory(senderId);
        const systemPrompt = `Voce e um assistente de desenvolvimento para Node.js/Baileys.\nResponda SEMPRE em JSON com os campos:\n{\n  "type": "code" | "advice" | "question",\n  "response": "texto",\n  "logic": "texto",\n  "commandName": "nome",\n  "commandTrigger": "/comando",\n  "code": "codigo",\n  "usage": "exemplo",\n  "isPublic": true\n}\nSe faltar contexto para criar comando, use type=question.\nSe for para criar comando, use type=code com codigo executavel ESM.`;

        const messages = [
            { role: 'system', content: systemPrompt },
            ...history,
            { role: 'user', content: effectivePrompt }
        ];

        const response = await groq.chat.completions.create({
            model: 'llama-3.3-70b-versatile',
            messages,
            max_tokens: 2000,
            temperature: 0.5,
            response_format: { type: 'json_object' }
        });

        const result = JSON.parse(response.choices[0].message.content);
        addToHistory(senderId, 'user', effectivePrompt);
        addToHistory(senderId, 'assistant', result.response || '');

        if (result.type === 'question') {
            await sendSafeMessage(sock, chatId, { text: `Pergunta: ${result.response}` });
            return;
        }

        if (result.type === 'advice') {
            await sendSafeMessage(sock, chatId, { text: `Sugestao: ${result.response}` });
            return;
        }

        if (result.type === 'code') {
            if (!result.commandName || !result.commandTrigger || !result.code) {
                await sendSafeMessage(sock, chatId, { text: 'Erro: resposta de codigo incompleta. Tente novamente.' });
                return;
            }
            try {
                validateGeneratedCommandResult(result);
            } catch (validationError) {
                await sendSafeMessage(sock, chatId, { text: `Erro na proposta de comando: ${validationError.message}` });
                return;
            }

            pendingCommandApproval.set(senderId, result);
            const preview = `3/3 Confirmacao\n\nComando: ${result.commandTrigger}\nArquivo: functions/custom/${result.commandName}.js\nPublico: ${result.isPublic ? 'Sim' : 'Nao'}\nUso: ${result.usage || 'Sem exemplo'}\n\nDescricao:\n${result.response || 'Sem descricao'}\n\nResponda APROVAR para criar ou CANCELAR para abortar.`;
            await sendSafeMessage(sock, chatId, { text: preview });
            return;
        }

        await sendSafeMessage(sock, chatId, { text: result.response || 'Nao entendi sua solicitacao.' });
    } catch (e) {
        await sendSafeMessage(sock, chatId, { text: `Erro: ${e.message}` });
    }
}
async function integrateCommand(commandName, trigger, isPublic) {
    const responderPath = path.join(__dirname, 'groupResponder.js');
    let content = fs.readFileSync(responderPath, 'utf8');

    // Adicionar import
    const importLine = `import { handle${capitalize(commandName)} } from './custom/${commandName}.js';`;
    if (!content.includes(importLine)) {
        const importPos = content.indexOf("import { handleSorteio }");
        if (importPos > -1) {
            content = content.replace(
                "import { handleSorteio } from './custom/sorteio.js';",
                `import { handleSorteio } from './custom/sorteio.js';\n${importLine}`
            );
        }
    }

    // Adicionar handler
    const handlerCode = `
    // Comando ${trigger} (${isPublic ? 'pÃºblico' : 'admin'})
    if (normalizedText.startsWith('${trigger.toLowerCase()}')) {
        ${isPublic ? '' : `
        const authorized = await isAuthorized(senderId);
        if (!authorized) {
            await sendSafeMessage(sock, groupId, { text: 'âŒ Apenas admins podem usar este comando.' });
            return;
        }`}
        await handle${capitalize(commandName)}(sock, message, text);
        return;
    }`;

    // Inserir antes dos comandos administrativos
    const insertPos = content.indexOf('// Comandos administrativos');
    if (insertPos > -1 && !content.includes(`Comando ${trigger}`)) {
        content = content.slice(0, insertPos) + handlerCode + '\n\n    ' + content.slice(insertPos);
    }

    fs.writeFileSync(responderPath, content);
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function ensureCommandHandlerExport(filePath, commandName) {
    const expectedHandler = `handle${capitalize(commandName)}`;
    let code = fs.readFileSync(filePath, 'utf8');

    if (new RegExp(`export\\s+(?:async\\s+)?function\\s+${expectedHandler}\\b`).test(code)) {
        return;
    }
    if (new RegExp(`export\\s+const\\s+${expectedHandler}\\b`).test(code)) {
        return;
    }

    const match = code.match(/export\s+(?:async\s+)?function\s+([A-Za-z_][A-Za-z0-9_]*)\s*\(/);
    if (!match || !match[1]) {
        return;
    }

    const sourceHandler = match[1];
    code += `\n\nexport async function ${expectedHandler}(sock, message, text) {\n    return ${sourceHandler}(sock, message, text);\n}\n`;
    fs.writeFileSync(filePath, code, 'utf8');
}

function readRecentLogs(lines = 20, maxChars = 3000) {
    const logFile = path.join(__dirname, '..', 'bot.log');
    if (!fs.existsSync(logFile)) {
        return { ok: false, message: 'Arquivo bot.log nao encontrado.' };
    }

    const safeLines = Math.min(80, Math.max(5, Number(lines) || 20));
    const allLines = fs.readFileSync(logFile, 'utf8').split(/\r?\n/);
    const recentLines = allLines.slice(-safeLines).join('\n').trim();

    if (!recentLines) {
        return { ok: false, message: 'bot.log esta vazio.' };
    }

    const clipped = recentLines.length > maxChars
        ? `...${recentLines.slice(-(maxChars - 3))}`
        : recentLines;

    return { ok: true, text: clipped, safeLines };
}
